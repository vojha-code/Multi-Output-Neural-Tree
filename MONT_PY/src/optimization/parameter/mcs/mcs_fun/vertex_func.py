import numpy as np
import math
import copy
#------------------------------------------------------------------------------
from src.optimization.parameter.mcs.mcs_fun.updtf import updtf
from src.optimization.parameter.mcs.mcs_fun.split_func import split1 
#------------------------------------------------------------------------------
def vertex(j,n,u,v,v1,x0,f0,ipar,isplit,ichild,z,f,l,L):
    '''
        # initialization
        # The coordinates of x, y, x1 and x2 are initially set to Inf to 
        # indicate that these quantities haven't been found yet in the course of
        # pursuing the history of box j
    '''
    x = np.multiply(np.Inf,np.ones(n))
    y = np.multiply(np.Inf,np.ones(n))
    x1 = np.multiply(np.Inf,np.ones(n))
    x2 = np.multiply(np.Inf,np.ones(n))
    f1 = np.zeros(n)
    f2 = np.zeros(n)
    # counting tthe number of time boxes has been split in ith direction
    n0 = np.zeros(n)
    fold = f[0,j]
    m = j
    
    while m > 0:
        if isplit[ipar[m]] < 0:
            i = int(abs(isplit[ipar[m]])) -1 #  negative 1 for making index fit to array in python
        else:
            i = int(abs(isplit[ipar[m]])) #  no negative 
            
        n0[i] = n0[i] + 1 # increase the counting tthe number of time boxes has been split in ith direction
        
        # ichild holds value from level 1 and not from level 0 there > 0 is ok
        if ichild[m] == 1:
            if x[i] == np.Inf or x[i] == z[0,ipar[m]]:
                x[i], x1[i], x2[i], f1[i], f2[i] = vert1(1,z[:,ipar[m]], f[:,ipar[m]], x1[i], x2[i], f1[i], f2[i])
            else:
                f1,f2,fold = updtf(n,i,x1,x2,f1,f2,fold,f[0,ipar[m]])
                x1[i],x2[i],f1[i],f2[i] = vert2(0,x[i],z[:,ipar[m]],f[:,ipar[m]],x1[i],x2[i],f1[i],f2[i])
        elif ichild[m] >= 2:
            f1,f2,fold = updtf(n,i,x1,x2,f1,f2,fold,f[0,ipar[m]])
            if x[i] == np.Inf or x[i] == z[1, ipar[m]]:
                x[i],x1[i],x2[i],f1[i],f2[i] = vert1(0,z[:,ipar[m]],f[:,ipar[m]],x1[i],x2[i],f1[i],f2[i])
            else:
                x1[i],x2[i],f1[i],f2[i] = vert2(1,x[i],z[:,ipar[m]],f[:,ipar[m]],x1[i],x2[i],f1[i],f2[i])
        
        # ichild holds value from level 1 and not from level 0 there > 0 is ok
        if 1 <= ichild[m] and ichild[m] <= 2 and y[i] == np.Inf:
            y[i] = split1(z[0,ipar[m]],z[1,ipar[m]],f[0,ipar[m]],f[1,ipar[m]])
        
        # ichild holds value from level 1 and not from level 0 there > 0 is ok
        if ichild[m] < 0:
            # box m was generated by splitting according to the init. list
            # x0[i,j1] = ith coordinate of the base vertex of box m
            # the ith coordinate of the opposite vertex is the golden section 
            # split of x0[i,j2] and x0[i,j2+1] for 1 <= j2 <= L[i] - 1, it is 
            # u[i] for j1 = 1 and v[i] for j2 = L[i] 
            # x0[i,j1+j3] = ith coordinate of the 'neighboring vertex'
            if u[i] < x0[i,0]:
                j1 = math.ceil(abs(ichild[m])/2)  
                j2 = math.floor(abs(ichild[m])/2)
                if (abs(ichild[m])/2 < j1 and j1 > 0) or j1 == L[i]+1:
                    j3 = -1
                else:
                    j3 = 1
            else:
                j1 = math.floor(abs(ichild[m])/2) + 1
                j2 = math.ceil(abs(ichild[m])/2)
                if abs(ichild[m])/2 + 1 > j1 and j1 < L[i]+1:
                    j3 = 1
                else:
                    j3 = -1
            #reduce index by 1 to fit to the dimenstion length for o to n-1
            j1 -=1
            j2 -=1
        
            if int(isplit[ipar[m]]) < 0: # box m was generated in the init. procedure
                k = copy.deepcopy(i)
            else:
                # box m was generated by a later split according to the init.
                # list; k points to the corresponding function values  
                k = int(z[0,ipar[m]])
            
            if j1 != l[i] or (x[i] != np.Inf and x[i] != x0[i,l[i]]):
                f1,f2,fold = updtf(n,i,x1,x2,f1,f2,fold,f0[l[i],k])
                
            if x[i] == np.Inf or x[i] == x0[i,j1]:
                x[i] = x0[i,j1]
                if x1[i] == np.Inf:
                    x1[i],x2[i],f1[i],f2[i] = vert3(j1,x0[i,:],f0[:,k],L[i],x1[i],x2[i],f1[i],f2[i])
                elif x2[i] == np.Inf and x1[i] != x0[i,j1+j3]:
                    x2[i] = x0[i,j1+j3]
                    f2[i] = f2[i] + f0[j1+j3,k]
                elif x2[i] == np.Inf:
                    if j1 != 1 and j1 != L[i]:
                        x2[i] = x0[i,j1-j3]
                        f2[i] = f2[i] + f0[j1-j3,k]
                    else:
                        x2[i] = x0[i,j1+2*j3]
                        f2[i] = f2[i] + f0[j1+2*j3,k]
                    #end j1 != 1
                #end x1[i] == np.Inf
            else:
                if x1[i] == np.Inf:
                    x1[i] = x0[i,j1]
                    f1[i] = f1[i] + f0[j1,k]
                    if x[i] != x0[i,j1+j3]:
                        x2[i] = x0[i,j1+j3];
                        f2[i] = f2[i] + f0[j1+j3,k]
                    # end  if x[i] != x0[i,j1+j3]
                elif x2[i] == np.Inf:
                    if x1[i] != x0[i,j1]:
                        x2[i] = x0[i,j1]
                        f2[i] = f2[i] + f0[j1,k]
                    elif x[i] != x0[i,j1+j3]:
                        x2[i] = x0[i,j1+j3]
                        f2[i] = f2[i] + f0[j1+j3,k]
                    else:
                        if j1 != 1 and j1 != L[i]:
                            x2[i] = x0[i,j1-j3]
                            f2[i] = f2[i] + f0[j1-j3,k]
                        else:
                            x2[i] = x0[i,j1+2*j3]
                            f2[i] = f2[i] + f0[j1+2*j3,k]
                        # end j1 != 1 and j1 != L[i]
                    # end x1[i] != x0[i,j1]
                #end x1[i] == np.Inf
            #end  x[i] == np.Inf or x[i] == x0[i,j1]
            if y[i] == np.Inf:
                if j2 == -1: #  make it nagative since in python index case it can become nagative
                    y[i] = u[i]
                elif j2 == L[i]:
                    y[i] = v[i]
                else:
                    y[i] = split1(x0[i,j2],x0[i,j2+1],f0[j2,k],f0[j2+1,k])
                #end
            #end if yi
        # end if ichild[m] < 0
        m = ipar[m]
    # end while
    for i in range(n):
        if x[i] == np.Inf:
            x[i] = x0[i,l[i]]
            x1[i],x2[i],f1[i],f2[i] = vert3(l[i],x0[i,:],f0[:,i],L[i],x1[i],x2[i],f1[i],f2[i])
        
        if y[i] == np.Inf:
            y[i] = v1[i]
            
    return n0,x,y,x1,x2,f1,f2


#------------------------------------------------------------------------------
def vert1(j,z,f,x1,x2,f1,f2):
    if j == 0:
        j1 = 1 # go to right to mid mid point 
    else:
        j1 = 0# go to left end
    
    x = z[j1]
    if x1 == np.Inf:
        x1 = z[j]
        f1 = f1 + f[j]
    elif x2 == np.Inf and x1 != z[j]:
        x2 = z[j]
        f2 = f2 + f[j]
        
    return x,x1,x2,f1,f2

#------------------------------------------------------------------------------
def vert2(j,x,z,f,x1,x2,f1,f2):
    if j == 0:
        j1 = 1 # go to right mid point
    else:
        j1 = 0 # go to left endpoint

    if x1 == np.Inf:
        x1 = z[j]
        f1 = f1 + f[j]
        if x != z[j1]:
            x2 = z[j1]
            f2 = f2 + f[j1]
        #end
    elif x2 == np.Inf and x1 != z[j]:
        x2 = z[j]
        f2 = f2 + f[j]
    elif x2 == np.Inf:
        x2 = z[j1]
        f2 = f2 + f[j1]
    #end
    return x1,x2,f1,f2


#------------------------------------------------------------------------------
def vert3(j,x0,f0,L,x1,x2,f1,f2):
    if j == 0:
        k1 = 1 # go right to 1 if already at left end (right end)
        k2 = 2 # go right if already at left end (exterme right end)
    elif j == L:
        k1 = L - 2 # go left to 0 (left end)
        k2 = L - 1 # go right to 2 (right end)
    else:
        k1 = j - 1 # go left to 0 (left end)
        k2 = j + 1 # go right to 2 (right end)
    #end if
    x1 = x0[k1]
    x2 = x0[k2]
    f1 = f1 + f0[k1]
    f2 = f2 + f0[k2]
    return x1,x2,f1,f2    



